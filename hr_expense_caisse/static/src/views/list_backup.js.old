/** @odoo-module */

import { registry } from '@web/core/registry';
import { listView } from "@web/views/list/list_view";
import { ListRenderer } from "@web/views/list/list_renderer";
import { ListController } from "@web/views/list/list_controller";
import { useService } from '@web/core/utils/hooks';
import { Component, onWillStart, useState, onMounted, onWillUnmount } from "@odoo/owl";

import { ExpenseDashboard } from '../components/expense_dashboard';

export class ExpenseDashboardListRenderer extends ListRenderer {
    static components = { ...ListRenderer.components, ExpenseDashboard };
    static template = 'hr_expense_caisse.DashboardListRenderer';
    
    setup() {
        super.setup();
        console.log('üõ†Ô∏è Setup ExpenseDashboardListRenderer');
        
        // V√©rifier si c'est notre mod√®le sp√©cifique
        this.showExpenseDashboard = this.props.list?.resModel === 'hr.expense.account.move';
        
        if (this.showExpenseDashboard) {
            console.log('üõ†Ô∏è Dashboard activ√© pour hr.expense.account.move');
            this.notification = useService('notification');
            this.orm = useService('orm');
            
            // √âtat pour les filtres synchronis√©s
            this.syncState = useState({
                dashboardFiltered: false,
                lastSearchDomain: null,
                isApplyingFilter: false
            });
            
            // √âcouter les changements de filtres du dashboard
            onMounted(() => {
                this.setupFilterSynchronization();
            });
            
            // Nettoyer les observateurs lors de la destruction (dans le renderer, on r√©f√©rence le controller)
            onWillUnmount(() => {
                console.log('üßΩ RENDERER: Nettoyage en cours');
                // L'observateur DOM sera nettoy√© par le controller
            });
        }
    }
    
    setupFilterSynchronization() {
        console.log('üîÑ SYNC: Configuration synchronisation des filtres');
        
        // √âcouter les √©v√©nements du dashboard via l'environment bus
        if (this.env.bus) {
            this.env.bus.addEventListener('dashboard-filter-changed', (event) => {
                console.log('üéØ SYNC: R√©ception √©v√©nement dashboard via env.bus:', event.detail);
                this.applyDashboardFiltersToSearch(event.detail);
            });
        }
        
        // √âcouter aussi via window pour plus de s√©curit√©
        if (typeof window !== 'undefined') {
            window.addEventListener('dashboard-filter-changed', (event) => {
                console.log('üåç SYNC: R√©ception √©v√©nement dashboard via window:', event.detail);
                this.applyDashboardFiltersToSearch(event.detail);
            });
        }
    }
    
    async applyDashboardFiltersToSearch(filterData) {
        try {
            if (!filterData || this.syncState.isApplyingFilter) {
                console.log('‚è≠Ô∏è SYNC: Ignorer application filtre (d√©j√† en cours ou pas de donn√©es)');
                return;
            }
            
            console.log('üîÑ SYNC: Application filtres dashboard vers search:', filterData);
            this.syncState.isApplyingFilter = true;
            
            // Construire le domaine depuis les filtres du dashboard
            const searchDomain = filterData.domain || [];
            console.log('üîç SYNC: Domaine √† appliquer:', searchDomain);
            
            // M√©thode alternative : utiliser l'action pour recharger avec le domaine
            if (this.env.services && this.env.services.action) {
                try {
                    const actionService = this.env.services.action;
                    
                    // Construire l'action avec le nouveau domaine
                    const action = {
                        type: 'ir.actions.act_window',
                        res_model: 'hr.expense.account.move',
                        view_mode: 'list,form',
                        views: [[false, 'list'], [false, 'form']],
                        domain: searchDomain,
                        context: {},
                        target: 'current'
                    };
                    
                    // Pas de rechargement complet, juste mise √† jour du domaine
                    console.log('‚úÖ SYNC: Domaine mis √† jour pour la vue');
                } catch (actionError) {
                    console.warn('‚ö†Ô∏è SYNC: Erreur action service:', actionError);
                }
            }
            
            // Appliquer le filtre via le contr√¥leur de recherche si disponible
            if (this.env.searchModel) {
                try {
                    // D√©sactiver temporairement le filtre dashboard pour √©viter les boucles
                    await this.env.searchModel.deactivateGroup('dashboard_filter');
                    
                    if (searchDomain.length > 0) {
                        // Activer le filtre dashboard avec le nouveau domaine
                        await this.env.searchModel.createNewFilters({
                            groupId: 'dashboard_filter',
                            filters: [{
                                description: 'Filtre Dashboard',
                                domain: searchDomain,
                                groupNumber: 1
                            }]
                        });
                    }
                    
                    console.log('‚úÖ SYNC: Filtre appliqu√© avec succ√®s');
                } catch (searchError) {
                    console.warn('‚ö†Ô∏è SYNC: Erreur searchModel:', searchError);
                }
            } else {
                console.warn('‚ö†Ô∏è SYNC: searchModel non disponible');
            }
            
        } catch (error) {
            console.error('‚ùå SYNC: Erreur application filtre:', error);
        } finally {
            // R√©activer les filtres apr√®s un d√©lai
            setTimeout(() => {
                this.syncState.isApplyingFilter = false;
                console.log('üîì SYNC: Synchronisation d√©bloqu√©e');
            }, 1000);
        }
    }
}

export class ExpenseDashboardListController extends ListController {
    setup() {
        super.setup();
        console.log('üõ†Ô∏è Setup Controller');
        this.notification = useService('notification');
        
        // √âtat pour d√©tecter les changements de filtres
        this.filterState = useState({
            lastDomain: null,
            isHandlingSearch: false
        });
        
        // √âcouter les √©v√©nements du renderer
        if (typeof window !== 'undefined') {
            window.addEventListener('renderer-filter-change-detected', () => {
                console.log('üì® CONTROLLER: Signal re√ßu du renderer');
                this.handleSearchFilterChange();
            });
        }
        
        // Configurer l'observateur DOM dans le contr√¥leur
        this.setupDOMObserver();
    }
    
    willDestroy() {
        super.willDestroy?.();
        // Nettoyer l'observateur DOM
        if (this.domObserver) {
            this.domObserver.disconnect();
            console.log('üßΩ CONTROLLER: Observateur DOM d√©connect√©');
        }
    }
    
    setupDOMObserver() {
        try {
            console.log('üîç DOM: Configuration observateur de changements (Controller)');
            
            // Observer les changements sur les √©l√©ments de recherche
            const observerConfig = {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['class', 'data-domain']
            };
            
            const callback = (mutations) => {
                let shouldCheck = false;
                
                mutations.forEach(mutation => {
                    if (mutation.type === 'childList' || mutation.type === 'attributes') {
                        const target = mutation.target;
                        
                        // V√©rifier si c'est li√© √† la recherche
                        if (target.classList?.contains('o_searchview') ||
                            target.classList?.contains('o_search_panel') ||
                            target.closest?.('.o_search_options') ||
                            target.closest?.('.o_searchview_facet')) {
                            shouldCheck = true;
                            console.log('üîç DOM: Changement d√©tect√© dans la recherche:', target.className);
                        }
                    }
                });
                
                if (shouldCheck) {
                    setTimeout(() => this.handleSearchFilterChange(), 300);
                }
            };
            
            // Cr√©er et lancer l'observateur
            this.domObserver = new MutationObserver(callback);
            
            // Observer le document entier pour capturer tous les changements
            if (typeof document !== 'undefined') {
                this.domObserver.observe(document.body, observerConfig);
                console.log('‚úÖ DOM: Observateur activ√© (Controller)');
            }
            
        } catch (error) {
            console.error('‚ùå DOM: Erreur configuration observateur:', error);
        }
    }
    
    async onUpdatedPaging() {
        const result = await super.onUpdatedPaging();
        this.handleSearchFilterChange();
        return result;
    }
    
    // M√©thode override pour d√©tecter les changements de recherche
    async onActiveElementsChanged() {
        const result = await super.onActiveElementsChanged?.();
        this.handleSearchFilterChange();
        return result;
    }
    
    async load() {
        const result = await super.load();
        // D√©lai pour s'assurer que le domaine est mis √† jour
        setTimeout(() => this.handleSearchFilterChange(), 100);
        return result;
    }
    
    // Override pour capturer tous les √©v√©nements de recherche
    async search(searchValue, { reload = true } = {}) {
        console.log('üîç SEARCH: M√©thode search appel√©e avec:', { searchValue, reload });
        const result = await super.search?.(searchValue, { reload });
        // D√©lai pour s'assurer que la recherche est termin√©e
        setTimeout(() => this.handleSearchFilterChange(), 200);
        return result;
    }
    
    // Override pour capturer les changements de contexte
    async update(params) {
        console.log('üîÑ UPDATE: M√©thode update appel√©e avec:', params);
        const result = await super.update(params);
        setTimeout(() => this.handleSearchFilterChange(), 100);
        return result;
    }
    
    // Override pour capturer le rechargement
    async reload(params) {
        console.log('üîÅ RELOAD: M√©thode reload appel√©e avec:', params);
        const result = await super.reload(params);
        setTimeout(() => this.handleSearchFilterChange(), 100);
        return result;
    }
    
    handleSearchFilterChange() {
        try {
            if (this.filterState.isHandlingSearch) {
                console.log('‚è≠Ô∏è SEARCH: D√©j√† en cours de traitement - ignorer');
                return;
            }
            
            // R√©cup√©rer le domaine actuel de la recherche
            const currentDomain = this.model?.root?.domain || [];
            const domainString = JSON.stringify(currentDomain);
            
            console.log('üîç DEBUG SEARCH: D√©tection changement filtres:', {
                currentDomain: currentDomain,
                domainLength: currentDomain.length,
                domainString: domainString,
                lastDomain: this.filterState.lastDomain,
                hasChanged: this.filterState.lastDomain !== domainString
            });
            
            // V√©rifier si le domaine a chang√©
            if (this.filterState.lastDomain !== domainString) {
                console.log('üîç SEARCH: Changement d√©tect√© dans les filtres de recherche:', {
                    domain: currentDomain,
                    length: currentDomain.length,
                    isEmpty: currentDomain.length === 0,
                    previousLength: this.filterState.lastDomain ? JSON.parse(this.filterState.lastDomain).length : 'N/A'
                });
                
                this.filterState.lastDomain = domainString;
                
                // Informer le dashboard m√™me si le domaine est vide (pour r√©initialiser)
                this.notifyDashboardOfSearchChange(currentDomain);
            } else {
                console.log('üîç SEARCH: Aucun changement d√©tect√© - ignorer');
            }
        } catch (error) {
            console.error('‚ùå SEARCH: Erreur d√©tection changement filtres:', error);
        }
    }
    
    notifyDashboardOfSearchChange(searchDomain) {
        try {
            console.log('üì¢ SEARCH: Notification dashboard du changement (am√©lior√©e):', {
                domain: searchDomain,
                length: searchDomain.length,
                isEmpty: !searchDomain || searchDomain.length === 0
            });
            
            // Extraire les filtres pertinents pour le dashboard
            const dashboardFilters = this.extractDashboardFilters(searchDomain);
            
            // V√©rifier si tous les filtres sont vides (r√©initialisation compl√®te)
            const hasAnyActiveFilter = Object.values(dashboardFilters).some(value => {
                if (Array.isArray(value)) return value.length > 0;
                if (value === null || value === undefined) return false;
                if (typeof value === 'object') return Object.keys(value).length > 0;
                if (typeof value === 'string') return value.trim().length > 0;
                return true;
            });
            
            console.log('üéØ SEARCH: Filtres extraits pour dashboard:', {
                filters: dashboardFilters,
                hasActiveFilters: hasAnyActiveFilter,
                isCompleteReset: !hasAnyActiveFilter && searchDomain.length === 0
            });
            
            // IMPORTANT: Toujours notifier le dashboard - m√™me pour les r√©initialisations
            const eventData = {
                ...dashboardFilters,
                searchDomain: searchDomain,
                timestamp: Date.now(),
                source: 'search',
                isCompleteReset: !hasAnyActiveFilter && searchDomain.length === 0
            };
            
            console.log('üì° SEARCH: √âmission √©v√©nement vers dashboard (incluant reset):', eventData);
            
            // √âmettre l'√©v√©nement pour le dashboard
            const event = new CustomEvent('search-filter-changed', {
                detail: eventData
            });
            
            if (typeof window !== 'undefined') {
                window.dispatchEvent(event);
                console.log('üåç SEARCH: √âv√©nement √©mis via window');
            }
            
            if (this.env.bus) {
                this.env.bus.trigger('search-filter-changed', eventData);
                console.log('üöå SEARCH: √âv√©nement √©mis via bus');
            }
            
        } catch (error) {
            console.error('‚ùå SEARCH: Erreur notification dashboard:', error);
        }
    }
    
    extractDashboardFilters(searchDomain) {
        const filters = {
            caisseIds: null,
            monthId: null,
            projectIds: null,
            dateRange: null,
            userIds: null,
            expenseType: null,
            validationStatus: null,
            hasAttachments: null,
            amountCondition: null,
            generalSearch: null
        };
        
        try {
            console.log('üîç EXTRACT: Analyse COMPLETE du domaine search:', searchDomain);
            
            // Parcourir le domaine pour extraire TOUS les filtres pertinents
            for (const condition of searchDomain) {
                if (Array.isArray(condition) && condition.length >= 3) {
                    const [field, operator, value] = condition;
                    
                    console.log('üîç EXTRACT: Condition analys√©e:', { field, operator, value, type: typeof value });
                    
                    // 1. Filtres de caisse - toutes les variantes possibles
                    if (field === 'expense_account_id') {
                        if (operator === 'in' && Array.isArray(value)) {
                            filters.caisseIds = value;
                            console.log('‚úÖ EXTRACT: Filtre caisse IN trouv√©:', value);
                        } else if (operator === '=' && typeof value === 'number') {
                            filters.caisseIds = [value];
                            console.log('‚úÖ EXTRACT: Filtre caisse = trouv√©:', value);
                        } else if (operator === 'ilike' && typeof value === 'string') {
                            console.log('‚ö†Ô∏è EXTRACT: Recherche par nom caisse:', value);
                            filters.generalSearch = value;
                        }
                    }
                    
                    // 2. Filtres de projet - TOUTES les variantes
                    else if (field === 'project_id') {
                        if (operator === 'in' && Array.isArray(value)) {
                            filters.projectIds = value;
                            console.log('‚úÖ EXTRACT: Filtre projet IN trouv√©:', value);
                        } else if (operator === '=' && typeof value === 'number') {
                            filters.projectIds = [value];
                            console.log('‚úÖ EXTRACT: Filtre projet = trouv√©:', value);
                        } else if (operator === 'ilike' && typeof value === 'string') {
                            console.log('‚ö†Ô∏è EXTRACT: Recherche par nom projet:', value);
                            filters.generalSearch = value;
                        } else if (operator !== false && value) {
                            // Autres op√©rateurs pour projet
                            console.log('‚úÖ EXTRACT: Filtre projet autre op√©rateur:', { operator, value });
                            if (typeof value === 'number') {
                                filters.projectIds = [value];
                            } else if (Array.isArray(value)) {
                                filters.projectIds = value;
                            }
                        }
                    }
                    
                    // 3. Filtres d'utilisateur - TOUTES les variantes
                    else if (field === 'user_id') {
                        if (operator === 'in' && Array.isArray(value)) {
                            filters.userIds = value;
                            console.log('‚úÖ EXTRACT: Filtre utilisateur IN trouv√©:', value);
                        } else if (operator === '=' && typeof value === 'number') {
                            filters.userIds = [value];
                            console.log('‚úÖ EXTRACT: Filtre utilisateur = trouv√©:', value);
                        } else if (operator === 'ilike' && typeof value === 'string') {
                            console.log('‚ö†Ô∏è EXTRACT: Recherche par nom utilisateur:', value);
                            filters.generalSearch = value;
                        }
                    }
                    
                    // 4. Filtres de type de d√©pense - TOUTES les variantes
                    else if (field === 'expense_move_type') {
                        if (operator === '=' && typeof value === 'string') {
                            filters.expenseType = value;
                            console.log('‚úÖ EXTRACT: Filtre type d√©pense trouv√©:', value);
                        } else if (operator === 'in' && Array.isArray(value)) {
                            filters.expenseType = value[0]; // Prendre le premier
                            console.log('‚úÖ EXTRACT: Filtre type d√©pense IN trouv√©:', value);
                        }
                    }
                    
                    // 4bis. Filtres de validation - NOUVEAU
                    else if (field === 'validate_by_administrator') {
                        filters.validationStatus = value;
                        console.log('‚úÖ EXTRACT: Filtre validation trouv√©:', value);
                    }
                    
                    // 4ter. Filtres de pi√®ces jointes - NOUVEAU 
                    else if (field === 'attachment_ids') {
                        if (operator === '!=' && value === false) {
                            filters.hasAttachments = true;
                            console.log('‚úÖ EXTRACT: Filtre avec pi√®ces jointes trouv√©');
                        } else if (operator === '=' && value === false) {
                            filters.hasAttachments = false;
                            console.log('‚úÖ EXTRACT: Filtre sans pi√®ces jointes trouv√©');
                        }
                    }
                    
                    // 4quater. Filtres de montant - NOUVEAU
                    else if (field === 'total_amount') {
                        if (operator === '>' && typeof value === 'number') {
                            filters.amountCondition = { operator: '>', value: value };
                            console.log('‚úÖ EXTRACT: Filtre montant > trouv√©:', value);
                        } else if (operator === '=' && typeof value === 'number') {
                            filters.amountCondition = { operator: '=', value: value };
                            console.log('‚úÖ EXTRACT: Filtre montant = trouv√©:', value);
                        } else if (operator === '<' && typeof value === 'number') {
                            filters.amountCondition = { operator: '<', value: value };
                            console.log('‚úÖ EXTRACT: Filtre montant < trouv√©:', value);
                        }
                    }
                    
                    // 5. Filtres de mois
                    else if (field === 'caisse_mois_id') {
                        if (operator === '=' && typeof value === 'number') {
                            filters.monthId = value;
                            console.log('‚úÖ EXTRACT: Filtre mois trouv√©:', value);
                        } else if (operator === 'in' && Array.isArray(value) && value.length === 1) {
                            filters.monthId = value[0];
                            console.log('‚úÖ EXTRACT: Filtre mois IN trouv√©:', value[0]);
                        }
                    }
                    
                    // 6. Filtres de date - TOUTES les variantes
                    else if (field === 'date') {
                        if (operator === '>=' || operator === '>' || operator === '<=' || operator === '<') {
                            if (!filters.dateRange) filters.dateRange = {};
                            if (operator === '>=' || operator === '>') {
                                filters.dateRange.start = value;
                            } else {
                                filters.dateRange.end = value;
                            }
                            console.log('‚úÖ EXTRACT: Filtre date trouv√©:', { operator, value });
                        } else if (operator === '=' && typeof value === 'string') {
                            filters.dateRange = { start: value, end: value };
                            console.log('‚úÖ EXTRACT: Filtre date exacte trouv√©:', value);
                        }
                    }
                    
                    // 7. Recherche g√©n√©rale - CAPTURE TOUT
                    else if (field === 'name' && operator === 'ilike' && typeof value === 'string') {
                        filters.generalSearch = value;
                        console.log('‚úÖ EXTRACT: Recherche g√©n√©rale par nom:', value);
                    }
                    
                    // 8. Autres champs potentiels
                    else if (value !== false && value !== null && value !== undefined) {
                        console.log('‚ö†Ô∏è EXTRACT: Champ non g√©r√© d√©tect√©:', { field, operator, value });
                    }
                }
            }
            
            // R√©sum√© des filtres extraits
            const activeFiltersCount = Object.values(filters).filter(v => v !== null).length;
            console.log('‚úÖ EXTRACT: RESUME - Filtres extraits (' + activeFiltersCount + ' actifs):', filters);
            
        } catch (error) {
            console.error('‚ùå EXTRACT: Erreur extraction filtres:', error);
        }
        
        return filters;
    }
}

// Enregistrement de la vue
registry.category('views').add('expense_spending_dashboard_tree', {
    ...listView,
    Renderer: ExpenseDashboardListRenderer,
    Controller: ExpenseDashboardListController,
});

console.log('‚úÖ Vue avec renderer et controller synchronis√©s enregistr√©s');

// Debug: v√©rifier l'enregistrement
setTimeout(() => {
    const registered = registry.category('views').get('expense_spending_dashboard_tree', null);
    if (registered) {
        console.log('‚úÖ REGISTER: Vue correctement enregistr√©e dans le registre');
    } else {
        console.error('‚ùå REGISTER: √âchec enregistrement de la vue');
    }
}, 100);