// WebSocket Service - Geo Lambert Project Management
import { getCurrentWebSocketUrl } from "./config/configService";
import io, { Socket } from "socket.io-client";
import projectCategoryService from "@/services/projectCategoryService";
import { authService } from "@/services/authService";
import { AppState, AppStateStatus } from 'react-native';

// ==================== SERVICE WEBSOCKET ====================

class WebSocketService {
    private name_project = "geo_lambert";
    private socket: Socket | null = null;
    private authuser: string | null = null;
    private pendingSubscriptions: (() => void)[] = []; // Private subscriptions waiting for auth
    private pendingPublicSubscriptions: (() => void)[] = []; // Public subscriptions waiting for socket connection
    private appState: AppStateStatus = 'active';
    async connect(): Promise<void> {
        if (this.socket && this.socket.connected) return;
        
        // Initialiser la gestion de l'√©tat de l'app si pas d√©j√† fait
        this.setupAppStateHandling();
        
        // Utiliser l'URL WebSocket configur√©e
        const wsUrl = getCurrentWebSocketUrl();
        
        console.log('üîó Connexion WebSocket Geo Lambert √†:', wsUrl);
        
        this.socket = io(wsUrl, {
            // Options pour maintenir la connexion
            forceNew: true,
            transports: ['websocket', 'polling'],
            timeout: 60000,
            reconnection: true,
            reconnectionAttempts: 10,
            reconnectionDelay: 2000,
            reconnectionDelayMax: 10000,
        });

        this.socket.on("connect", async () => {
            console.log("üîó D√©but de la connexion WebSocket...");

            // 1. EX√âCUTER IMM√âDIATEMENT LES SOUSCRIPTIONS PUBLIQUES
            console.log("üì° Ex√©cution des souscriptions publiques (sans auth):", this.pendingPublicSubscriptions.length);
            this.pendingPublicSubscriptions.forEach((subscription, index) => {
                console.log("üåê Ex√©cution souscription publique #" + (index + 1));
                subscription();
            });
            this.pendingPublicSubscriptions = [];
            console.log("‚úÖ Toutes les souscriptions publiques ont √©t√© ex√©cut√©es");

            // 2. ESSAYER D'AUTHENTIFIER ET EX√âCUTER LES SOUSCRIPTIONS PRIV√âES
            try {
                let user = await authService.getCurrentUser();
                console.log("üì§ R√©cup√©ration utilisateur:", user);

                // V√©rifier si c'est d√©j√† un objet ou une cha√Æne
                if (typeof user === 'string') {
                    console.log("üîÑ Parsing JSON n√©cessaire...");
                    user = JSON.parse(user);
                } else {
                    console.log("‚úÖ Objet d√©j√† pars√©, pas de JSON.parse n√©cessaire");
                }

                // @ts-ignore
                this.authuser = user.id

                // Ex√©cuter les souscriptions priv√©es en attente
                console.log("üîí Souscriptions priv√©es en attente:", this.pendingSubscriptions.length);
                this.pendingSubscriptions.forEach((subscription, index) => {
                    console.log("üéØ Ex√©cution souscription priv√©e #" + (index + 1));
                    subscription();
                });
                this.pendingSubscriptions = [];
                console.log("‚úÖ Toutes les souscriptions priv√©es ont √©t√© ex√©cut√©es");
                
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'authentification:', error);
                console.log('‚ö†Ô∏è Seules les souscriptions publiques sont actives');
            }

        });

        this.socket.on("disconnect", async (reason) => {
            console.log("üîå WebSocket d√©connect√©:", reason);
        });

        this.socket.on(`connect_error_${this.name_project}`, (err) => {
            console.error("‚ùå Erreur connexion WS:", err.message);
        });
    }
    disconnect(): void {
        this.socket?.disconnect();
        this.socket = null;
        this.authuser = null;

        // Nettoyer TOUTES les souscriptions en attente
        this.pendingSubscriptions = []; // Private subscriptions
        this.pendingPublicSubscriptions = []; // Public subscriptions
        console.log('‚úÖ WebSocket d√©connect√© et nettoy√© (souscriptions priv√©es et publiques)');
    }
    private setupAppStateHandling(): void {
        if (this.appState !== 'active') return; // D√©j√† configur√©
        
        console.log('üì± Configuration de la gestion d\'√©tat de l\'app...');
        
        AppState.addEventListener('change', this.handleAppStateChange);
        this.appState = AppState.currentState;
        
        console.log('‚úÖ Gestion d\'√©tat de l\'app activ√©e, √©tat actuel:', this.appState);
    }
    private handleAppStateChange = (nextAppState: AppStateStatus) => {

        this.appState = nextAppState;
    };
    subscribe(event: string, callback: (msg: any) => void): void {
        this.socket?.on(event, callback);
    }
    /**
     * Souscription aux mises √† jour de t√¢ches
     */
    onTaskUpdate(callback: (task: any) => void): void {
        const subscribeToTasks = () => {
            if (!this.authuser) {
                return;
            }
            const privateTaskChannel = `${this.name_project}_tasks_user_id_${this.authuser}`;

            this.subscribe(privateTaskChannel, async (data: any) => {
                try {
                    // V√©rifier si les donn√©es sont d√©j√† pars√©es
                    console.log(JSON.stringify(data, null, 2));
                    let parsedTask;
                    if (typeof data === 'string') {
                        parsedTask = JSON.parse(data);
                    } else {
                        parsedTask = data;
                    }

                    // Traiter selon le type d'√©v√©nement
                    const eventType = parsedTask.event_type || 'updated';
                    let success = false;
                    switch (eventType) {
                        case 'created':
                        case 'updated':
                        case 'sync':
                        case 'started':
                        case 'stopped':
                        case 'state_changed':
                            // Recharger les cat√©gories depuis SQLite pour avoir les derni√®res donn√©es
                            const categoriesResponse = await projectCategoryService.getProjectCategories();
                            success = categoriesResponse.success;
                            break;
                        case 'deleted':
                            // Pour les suppressions, aussi recharger les cat√©gories
                            const deleteCategoriesResponse = await projectCategoryService.getProjectCategories();
                            success = deleteCategoriesResponse.success;
                            if (success) {
                                console.log(`üóëÔ∏è Projet ${parsedTask.id} supprim√© (task deleted)`);
                            }
                            break;
                        default:
                            console.log('‚ö†Ô∏è Type d\'√©v√©nement t√¢che non g√©r√©:', eventType);
                            success = true;
                    }

                    if (success) {
                        callback(parsedTask);
                    } else {
                        console.error('‚ùå √âchec traitement t√¢che depuis socket:', parsedTask.id || 'ID inconnu');
                    }
                } catch (error) {
                    console.error('‚ùå Erreur traitement t√¢che socket:', error);
                    console.error('üìä Stack trace:', error);
                }
            });
        };

        if (this.authuser) {
            subscribeToTasks();
        } else {
            this.pendingSubscriptions.push(subscribeToTasks);
        }
    }
    onProjectUpdate(callback: (project: any) => void): void {
        const subscribeToProjects = () => {
            if (!this.authuser) return;

            const privateProjectChannel = `${this.name_project}_expenses`;
            
            this.subscribe(privateProjectChannel, async (data: any) => {
                try {
                    console.log(JSON.stringify(JSON.parse(data), null, 2));
                    let parsedProject = typeof data === 'string' ? JSON.parse(data) : data;
                    const eventType = parsedProject.event_type || 'updated';
                    let success = false;

                    switch (eventType) {
                        case 'created':
                        case 'updated':
                        case 'sync':
                            // ‚úÖ V√©rifier s'il y a une d√©pense supprim√©e
                            if (parsedProject.deleted_expense_id) {
                                console.log(`üóëÔ∏è D√©pense ${parsedProject.deleted_expense_id} supprim√©e`);
                                if (parsedProject.task_id_with_deleted_expense) {
                                    console.log(`   de la t√¢che ${parsedProject.task_id_with_deleted_expense}`);
                                }
                            }
                            // üíæ INSERT OR REPLACE le projet dans SQLite avec sa cat√©gorie
                            success = await projectCategoryService.insertOrUpdateProject(parsedProject);
                            if (success) {
                                console.log(`‚úÖ Projet ${parsedProject.id} mis √† jour via WebSocket`);
                            } else {
                                console.warn(`‚ö†Ô∏è √âchec mise √† jour projet ${parsedProject.id} via WebSocket`);
                            }
                            break;
                        case 'deleted':
                            // ‚úÖ V√©rifier si c'est une suppression de t√¢che ou de projet
                            if (parsedProject.deleted_task_id) {
                                // Suppression d'une t√¢che individuelle
                                console.log(`üóëÔ∏è T√¢che ${parsedProject.deleted_task_id} supprim√©e du projet ${parsedProject.id}`);
                                // Recharger les cat√©gories pour mettre √† jour la t√¢che
                                const categoriesResponse = await projectCategoryService.getProjectCategories();
                                success = categoriesResponse.success;
                            } else {
                                // Suppression du projet entier
                                console.log(`üóëÔ∏è Projet ${parsedProject.id} supprim√© (project deleted)`);
                                success = await projectCategoryService.deleteProject(parsedProject.id);
                            }
                            break;
                        default:
                            console.log('‚ö†Ô∏è Type √©v√©nement projet non g√©r√©:', eventType);
                            success = true;
                    }

                    if (success) {
                        callback(parsedProject);
                    }
                } catch (error) {
                    console.error('‚ùå Erreur traitement projet socket:', error);
                }
            });
        };

        if (this.authuser) {
            subscribeToProjects();
        } else {
            this.pendingSubscriptions.push(subscribeToProjects);
        }
    }
    /**
     * Souscription aux mises √† jour de d√©penses de caisse
     * ‚úÖ Channel PRIV√â - case_id + user_id
     */
    onCashboxExpenseUpdate(callback: (data: any) => void): void {
        const subscribeToCashboxExpenses = () => {
            if (!this.authuser) {
                console.log('‚ö†Ô∏è Pas d\'authentification pour les d√©penses de caisse');
                return;
            }

            // R√©cup√©rer le case_id depuis l'auth
            const getUserInfo = async () => {
                try {
                    const user = await authService.getCurrentUser();
                    if (!user || !user.case_id) {
                        console.error('‚ùå case_id manquant dans user auth');
                        return null;
                    }
                    return user;
                } catch (error) {
                    console.error('‚ùå Erreur r√©cup√©ration user info:', error);
                    return null;
                }
            };

            getUserInfo().then(user => {
                if (!user) return;

                // ‚úÖ Canal priv√©: geo_lambert_expense_caise_{case_id}_{user_id}
                const privateCashboxChannel = `${this.name_project}_expense_caise_${user.case_id}_${this.authuser}`;
                console.log('üì° Souscription au canal d√©penses de caisse:', privateCashboxChannel);

                this.subscribe(privateCashboxChannel, async (data: any) => {
                    try {
                        console.log('üì• Donn√©es d√©pense de caisse re√ßues:', typeof data === 'string' ? 'string' : 'object');
                        
                        let parsedData;
                        if (typeof data === 'string') {
                            parsedData = JSON.parse(data);
                        } else {
                            parsedData = data;
                        }

                        callback(parsedData);

                    } catch (error) {
                        console.error('‚ùå Erreur traitement d√©pense de caisse socket:', error);
                        console.error('üìä Donn√©es brutes:', data);
                    }
                });
            });
        };

        // ‚úÖ Attendre l'authentification avant de s'abonner
        if (this.authuser) {
            subscribeToCashboxExpenses();
        } else {
            this.pendingSubscriptions.push(subscribeToCashboxExpenses);
        }
    }

    /**
     * Souscription aux mises √† jour de mois de d√©penses
     * ‚úÖ Channel PRIV√â - case_id + user_id
     */
    onExpenseMonthUpdate(callback: (data: any) => void): void {
        const subscribeToExpenseMonths = () => {
            if (!this.authuser) {
                console.log('‚ö†Ô∏è Pas d\'authentification pour les mois de d√©penses');
                return;
            }

            // R√©cup√©rer le case_id depuis l'auth
            const getUserInfo = async () => {
                try {
                    const user = await authService.getCurrentUser();
                    if (!user || !user.case_id) {
                        console.error('‚ùå case_id manquant dans user auth');
                        return null;
                    }
                    return user;
                } catch (error) {
                    console.error('‚ùå Erreur r√©cup√©ration user info:', error);
                    return null;
                }
            };

            getUserInfo().then(user => {
                if (!user) return;

                // ‚úÖ Canal priv√©: geo_lambert_expense_month_caise_{case_id}_{user_id}
                const privateMonthChannel = `${this.name_project}_expense_month_caise_${user.case_id}_${this.authuser}`;
                console.log('üì° Souscription au canal mois de d√©penses:', privateMonthChannel);

                this.subscribe(privateMonthChannel, async (data: any) => {
                    try {
                        console.log('üì• Donn√©es mois de d√©penses re√ßues:', typeof data === 'string' ? 'string' : 'object');
                        
                        let parsedData;
                        if (typeof data === 'string') {
                            parsedData = JSON.parse(data);
                        } else {
                            parsedData = data;
                        }

                        callback(parsedData);

                    } catch (error) {
                        console.error('‚ùå Erreur traitement mois de d√©penses socket:', error);
                        console.error('üìä Donn√©es brutes:', data);
                    }
                });
            });
        };

        // ‚úÖ Attendre l'authentification avant de s'abonner
        if (this.authuser) {
            subscribeToExpenseMonths();
        } else {
            this.pendingSubscriptions.push(subscribeToExpenseMonths);
        }
    }

    /**
     * Souscription aux mises √† jour de cat√©gories de projets
     * ‚ö†Ô∏è Channel PUBLIC - Pas besoin d'authentification
     */
    onCategoryUpdate(callback: (category: any) => void): void {
        const subscribeToCategories = () => {
            // ‚úÖ Channel PUBLIC pour les cat√©gories
            const publicCategoryChannel = `${this.name_project}_category_projects`;

            console.log('üì° Souscription au channel cat√©gories:', publicCategoryChannel);

            this.subscribe(publicCategoryChannel, async (data: any) => {
                try {
                    let parsedCategory;
                    if (typeof data === 'string') {
                        parsedCategory = JSON.parse(data);
                    } else {
                        parsedCategory = data;
                    }

                    console.log('üì• Cat√©gorie re√ßue via WebSocket:', {
                        id: parsedCategory.id,
                        name: parsedCategory.name,
                        event_type: parsedCategory.event_type,
                        project_count: parsedCategory.project_ids?.length || 0
                    });

                    const eventType = parsedCategory.event_type || 'updated';

                    let success = false;

                    switch (eventType) {
                        case 'created':
                        case 'updated':
                        case 'sync':
                            // üíæ INSERT OR REPLACE dans SQLite
                            success = await projectCategoryService.insertOrUpdateCategory(parsedCategory);
                            if (success) {
                                console.log(`‚úÖ Cat√©gorie ${parsedCategory.id} (${parsedCategory.name}) - INSERT OR REPLACE r√©ussi`);
                            }
                            break;
                        case 'deleted':
                            // üóëÔ∏è DELETE de SQLite
                            success = await projectCategoryService.deleteCategory(parsedCategory.id);
                            if (success) {
                                console.log(`üóëÔ∏è Cat√©gorie ${parsedCategory.id} supprim√©e de SQLite`);
                            }
                            break;
                        default:
                            console.log('‚ö†Ô∏è Type d\'√©v√©nement cat√©gorie non g√©r√©:', eventType);
                            success = true;
                    }

                    if (success) {
                        callback(parsedCategory);
                    } else {
                        console.error('‚ùå √âchec traitement cat√©gorie depuis socket:', parsedCategory.id || 'ID inconnu');
                    }
                } catch (error) {
                    console.error('‚ùå Erreur traitement cat√©gorie socket:', error);
                }
            });
        };

        // ‚úÖ Souscription PUBLIQUE - Pas besoin d'attendre l'auth
        if (this.socket && this.socket.connected) {
            subscribeToCategories();
        } else {
            this.pendingPublicSubscriptions.push(subscribeToCategories);
        }
    }
    onConnectionStatusChange(callback: (connected: boolean) => void): void {
        this.socket?.on("connect", async () => {
            callback(true);
            console.log("Connected!");
        });
        this.socket?.on("disconnect", async () => {
            callback(false);
        });
    }

    // Unsubscribe from all events (useful for cleanup)
    unsubscribeAll(): void {
        console.log('üßπ D√©but du nettoyage des listeners...');

        if (!this.socket) {
            console.log('‚ö†Ô∏è Pas de socket √† nettoyer');
            return;
        }

        // Unsubscribe from private channels if user is authenticated
        if (this.authuser) {
            // Canaux Geo Lambert Project Management
            const privateProjectChannel = `${this.name_project}_projects_user_id_${this.authuser}`;
            const privateTaskChannel = `${this.name_project}_tasks_user_id_${this.authuser}`;
            const privateExpenseChannel = `${this.name_project}_expenses_user_id_${this.authuser}`;
            const privateExpenseDeleteChannel = `${this.name_project}_expenses_delete_user_id_${this.authuser}`;

            // Legacy channels
            const privateCommandChannel = `command_user_id_${this.authuser}`;
            const privateOrderDeleteChannel = `order_delete_user_id_${this.authuser}`;
            const privateProductChannel = `products_user_id_${this.authuser}`;
            const privateProductDeleteChannel = `products_delete_user_id_${this.authuser}`;
            const privateEditProfileChannel = `edit_profil_${this.authuser}`;
            const privateUserMessageChannel = `user_message_${this.authuser}_${this.name_project}`;

            // Nettoyage canaux Geo Lambert
            console.log('üîí Nettoyage du canal priv√© projets:', privateProjectChannel);
            this.socket.off(privateProjectChannel);

            console.log('üîí Nettoyage du canal priv√© t√¢ches:', privateTaskChannel);
            this.socket.off(privateTaskChannel);

            console.log('üîí Nettoyage du canal priv√© d√©penses:', privateExpenseChannel);
            this.socket.off(privateExpenseChannel);

            console.log('üîí Nettoyage du canal priv√© suppression d√©penses:', privateExpenseDeleteChannel);
            this.socket.off(privateExpenseDeleteChannel);

            // Nettoyage canal cat√©gories (legacy priv√©)
            const privateCategoryChannel = `${this.name_project}_categories_user_id_${this.authuser}`;
            console.log('üîí Nettoyage du canal priv√© cat√©gories (legacy):', privateCategoryChannel);
            this.socket.off(privateCategoryChannel);

            // Nettoyage canaux legacy
            console.log('üîí Nettoyage du canal priv√© commandes (legacy):', privateCommandChannel);
            this.socket.off(privateCommandChannel);

            console.log('üîí Nettoyage du canal priv√© suppression commandes (legacy):', privateOrderDeleteChannel);
            this.socket.off(privateOrderDeleteChannel);

            console.log('üîí Nettoyage du canal priv√© produits (legacy):', privateProductChannel);
            this.socket.off(privateProductChannel);

            console.log('üîí Nettoyage du canal priv√© suppression produits (legacy):', privateProductDeleteChannel);
            this.socket.off(privateProductDeleteChannel);

            console.log('üîí Nettoyage du canal priv√© √©dition profil:', privateEditProfileChannel);
            this.socket.off(privateEditProfileChannel);

            console.log('üîí Nettoyage du canal priv√© messages utilisateur:', privateUserMessageChannel);
            this.socket.off(privateUserMessageChannel);
        } else {
            console.log('‚ö†Ô∏è Pas d\'utilisateur authentifi√©, pas de canaux priv√©s √† nettoyer');
        }

        // Nettoyer les canaux priv√©s d√©penses de caisse et mois si utilisateur authentifi√©
        if (this.authuser) {
            // Note: On ne peut pas r√©cup√©rer facilement le case_id ici de mani√®re synchrone
            // mais on peut nettoyer le pattern g√©n√©ral
            console.log(`üîí Nettoyage des canaux priv√©s d√©penses de caisse pour user ${this.authuser}`);
            console.log(`üîí Nettoyage des canaux priv√©s mois de d√©penses pour user ${this.authuser}`);
            // On nettoie tous les canaux qui matchent le pattern
            // Note: socket.io ne permet pas de lister tous les channels, donc on fait un best effort
        }

        // Nettoyer les canaux publics
        console.log(`üì° Nettoyage du canal public cat√©gories: ${this.name_project}_category_aprojects`);
        this.socket.off(`${this.name_project}_category_aprojects`);

        console.log(`üì° Nettoyage du canal public messages Geo Lambert app: message_app_${this.name_project}`);
        this.socket.off(`message_app_${this.name_project}`);

        console.log(`üì° Nettoyage du canal public messages app (legacy): message_app_${this.name_project}`);
        this.socket.off(`message_app_${this.name_project}`);

        console.log('üì° Nettoyage du canal public produits: products');
        this.socket.off('products');

        console.log(`üì° Nettoyage du canal public messages: message_${this.name_project}`);
        this.socket.off(`message_${this.name_project}`);

        // Nettoyer les listeners g√©n√©raux
        this.socket.off('connect');
        this.socket.off('disconnect');

        console.log('üóëÔ∏è Tous les listeners WebSocket supprim√©s avec succ√®s');
    }
}

export const webSocketService = new WebSocketService();
export default webSocketService;
